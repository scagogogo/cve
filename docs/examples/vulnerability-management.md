# Vulnerability Database Management

This example demonstrates how to use CVE Utils to manage large vulnerability databases.

## Scenario Description

As a security product developer or vulnerability database maintainer, you need to:
- Import CVE data from multiple data sources
- Clean and validate data quality
- Classify and organize data by various criteria
- Provide efficient query and export functionality

## Complete Example

```go
package main

import (
    "fmt"
    "time"
    "github.com/scagogogo/cve"
)

// VulnerabilityRecord vulnerability record structure
type VulnerabilityRecord struct {
    CVE         string    `json:"cve"`
    Year        int       `json:"year"`
    Sequence    int       `json:"sequence"`
    Title       string    `json:"title,omitempty"`
    Description string    `json:"description,omitempty"`
    Severity    string    `json:"severity,omitempty"`
    Source      string    `json:"source,omitempty"`
    ImportDate  time.Time `json:"import_date"`
    LastUpdate  time.Time `json:"last_update"`
}

// VulnerabilityDatabase vulnerability database manager
type VulnerabilityDatabase struct {
    records    map[string]*VulnerabilityRecord
    sources    map[string]int
    statistics DatabaseStats
}

type DatabaseStats struct {
    TotalRecords     int                    `json:"total_records"`
    RecordsByYear    map[string]int         `json:"records_by_year"`
    RecordsBySource  map[string]int         `json:"records_by_source"`
    LastUpdateTime   time.Time              `json:"last_update_time"`
    DataQualityScore float64                `json:"data_quality_score"`
}

func NewVulnerabilityDatabase() *VulnerabilityDatabase {
    return &VulnerabilityDatabase{
        records: make(map[string]*VulnerabilityRecord),
        sources: make(map[string]int),
        statistics: DatabaseStats{
            RecordsByYear:   make(map[string]int),
            RecordsBySource: make(map[string]int),
        },
    }
}

func (db *VulnerabilityDatabase) ImportFromText(content, source string) (int, error) {
    imported := 0
    cves := cve.ExtractCve(content)
    
    for _, cveId := range cves {
        if !cve.ValidateCve(cveId) {
            continue
        }
        
        if _, exists := db.records[cveId]; exists {
            db.records[cveId].LastUpdate = time.Now()
            continue
        }
        
        record := &VulnerabilityRecord{
            CVE:        cveId,
            Year:       cve.ExtractCveYearAsInt(cveId),
            Sequence:   cve.ExtractCveSeqAsInt(cveId),
            Source:     source,
            ImportDate: time.Now(),
            LastUpdate: time.Now(),
        }
        
        db.records[cveId] = record
        imported++
    }
    
    db.sources[source] += imported
    db.updateStatistics()
    
    return imported, nil
}

func (db *VulnerabilityDatabase) updateStatistics() {
    db.statistics.TotalRecords = len(db.records)
    db.statistics.LastUpdateTime = time.Now()
    
    db.statistics.RecordsByYear = make(map[string]int)
    db.statistics.RecordsBySource = make(map[string]int)
    
    for _, record := range db.records {
        yearStr := fmt.Sprintf("%d", record.Year)
        db.statistics.RecordsByYear[yearStr]++
        
        if record.Source != "" {
            db.statistics.RecordsBySource[record.Source]++
        }
    }
}

func main() {
    db := NewVulnerabilityDatabase()
    
    sampleText := `
    Security Advisory 2024-001
    This advisory addresses CVE-2021-44228 and CVE-2022-12345.
    `
    
    imported, _ := db.ImportFromText(sampleText, "Security Advisory")
    fmt.Printf("Imported %d CVEs\n", imported)
    
    stats := db.statistics
    fmt.Printf("Total records: %d\n", stats.TotalRecords)
    fmt.Printf("Records by year: %v\n", stats.RecordsByYear)
}
```

## Key Features

1. **Multi-source Import**: Support importing from text and other formats
2. **Data Validation**: Comprehensive CVE format validation
3. **Statistical Analysis**: Automatic generation of database statistics
4. **Data Management**: Efficient storage and retrieval

## Best Practices

1. **Regular Data Cleaning**: Periodically clean and validate data
2. **Source Tracking**: Always track data sources for traceability
3. **Performance Optimization**: Use appropriate indexing for large datasets
